\chapter{The Ethernet Model}
\label{cha:ethernet}

% TODO: comment numWirelessPorts in MacRelayUnitPP
% TODO: comment origByteLength in EtherFrame
% FIXME: wrong header length in EtherFrame.msg

\section{Overview}

Variations: 10Mb/s ethernet, fast ethernet, Gigabit Ethernet, Fast Gigabit Ethernet, full duplex

The Ethernet model contains a MAC model (\nedtype{EtherMAC}), LLC model (\nedtype{EtherLLC}) as well
as a bus (\nedtype{EtherBus}, for modelling coaxial cable) and a hub (\nedtype{EtherHub}) model.
A switch model (\nedtype{EtherSwitch}) is also provided.

\begin{itemize}
  \item \nedtype{EtherHost} is a sample node with an Ethernet NIC;
  \item \nedtype{EtherSwitch}, \nedtype{EtherBus}, \nedtype{EtherHub} model switching hub, repeating hub and
        the old coxial cable;
  \item basic compnents of the model: \nedtype{EtherMAC}, \nedtype{EtherLLC}/\nedtype{EtherEncap} module types,
        \nedtype{MACRelayUnit} (\nedtype{MACRelayUnitNP} and \nedtype{MACRelayUnitPP}), \nedtype{EtherFrame} message type,
        \cppclass{MACAddress} class
\end{itemize}

Sample simulations:

\begin{itemize}
  \item the \nedtype{MixedLAN} model contains hosts, switch, hub and bus
  \item the \nedtype{LargeNet} model contains hundreds of computers, switches and hubs
        (numbers depend on model configuration in largenet.ini) and mixes all
        kinds of Ethernet technologies
\end{itemize}

\subsection{Implemented Standards}

The Ethernet model operates according to the following standards:

\begin{itemize}
  \item Ethernet: IEEE 802.3-1998
  \item Fast Ethernet: IEEE 802.3u-1995
  \item Full-Duplex Ethernet with Flow Control: IEEE 802.3x-1997
  \item Gigabit Ethernet: IEEE 802.3z-1998
\end{itemize}

Note: switches don't implement the Spanning Tree Protocol. You need to
avoid cycles in the LAN topology.

\section{Physical layer}

The nodes of the Ethernet networks are connected by coaxial,
twisted pair or fibre cables. There are several cable types specified
in the standard.

In the INET framework, the cables are represented by connections.
The connections used in Ethernet LANs must be derived from
\nedtype{DatarateConnection} and should have their \fpar{delay} and
\fpar{datarate} parameters set.
The delay parameter can be used to model the distance between the
nodes. The datarate parameter can have four values:

\begin{itemize}
  \item \ttt{10Mbps} classic Ethernet
  \item \ttt{100Mbps} Fast Ethernet
  \item \ttt{1Gbps} Gigabit Ethernet
  \item \ttt{10Gbps} Fast Gigabit Ethernet
\end{itemize}


\subsection{EtherBus}

The \nedtype{EtherBus} component can model a common coaxial cable
found in earlier Ethernet LANs. The nodes are attached at specific
positions of the cable. If a node sends a packet, it is transmitted
in both direction by a given propagation speed.

The gates of the \nedtype{EtherBus} represent taps. The positions
of the taps are given by the \fpar{positions} parameter as a
space separated list of distances in metres. If there are more
gates then positions given, the last distance is repeated.
The bus component send the incoming message in one direction and
a copy of the message to the other direction (except at the ends).
The propagation delays are computed from the distances of the taps
and the \fpar{propagationSpeed} parameter.

Messages are not interpreted by the bus model in any way, thus the bus
model is not specific to Ethernet in any way. Messages may
represent anything, from the beginning of a frame transmission to
end (or abortion) of transmission.

% FIXME #356 NED comment is wrong: data rate must not be zero!
% FIXME #354 default propagation speed is wrong (should be 2e8mps)
%            btw there is a hard coded propagation speed in EtherMACBase.cc

\subsection{EtherHub}

Ethernet hubs are a simple broadcast devices. Messages arriving on a port
are regenerated and broadcast to every other port.

The connections connected to the hub must have the same data rate.
Cable lengths should be reflected in the delays of the connections.

Messages are not interpreted by the \nedtype{EtherType} hub model in aby way,
thus the hub model is not specific to Ethernet. Messages may
represent anything, from the beginning of a frame transmission to
end (or abortion) of transmission.

The hub module collects the following statistics:

\begin{itemize}
\item \ttt{pkBytes} handled packets length (vector)
\item \ttt{messages/sec} number of packets per seconds (scalar)
\end{itemize}

% FIXME #356 NED comment is wrong: data rate must not be zero!
% TODO: model delay in hubs: class I device 140 bit time, class II device 92 bit time (for fast ethernet)

\section{MAC layer}

\subsection{IEtherMAC}

defined in inet.linklayer

Interface for Ethernet MAC implementations. All Ethernet MAC implementations
should implement this (i.e. declared as: EtherMAC like IEtherMAC).
The existing implementations are these: \nedtype{EtherMAC} and
\nedtype{EtherMACFullDuplex}.

Expected environment:
\begin{itemize}
\item \verb!phys$i! and \verb!phys$o! should be connected to the "network"
\item upperLayerIn and upperLayerOut are usually connected to
  nedtype{EtherLLC} (in hosts) or \nedtype{MACRelayUnitPP} (in a switch)
\end{itemize}

The module does not perform encapsulation or decapsulation of frames --
this is done by higher layers (\nedtype{EtherLLC} or \nedtype{EtherEncap}).

When a frame is received from the higher layers, it must be an
\msgtype{EtherFrame}, and with all protocol fields filled out
(including the destination MAC address). The source address, if left empty,
will be filled in. Then frame is queued and transmitted according
to the CSMA/CD protocol.

Data frames received from the network are EtherFrames. They are passed to
the higher layers without modification.
Also, the module properly responds to PAUSE frames, but never sends them
by itself -- however, it transmits PAUSE frames received from upper layers.
See section~\ref{pause_handling} for more info.

The \nedtype{IEtherMAC} interface has two implementation: \nedtype{EtherMAC}
and \nedtype{EtherMACFullDuplex}, both derived from \nedtype{EtherMACBase}.
\nedtype{EtherMAC} is more general and can transmit frames using the CSMA/CD protocol,
\nedtype{EtherMACFullDuplex} works only with duplex connections without CSMA/CD.

% TODO document auto MAC address, using host names as destAddress
Ethernet Auto-Negotiation not supported

\tbf{Disabling and disconnecting}

If the MAC is not connected to the network ("cable unplugged"), it will
start up in "disabled" mode. A disabled MAC simply discards any messages
it receives. It is currently not supported to dynamically connect/disconnect
a MAC.


\tbf{Queueing}

In routers, MAC relies on an external queue module (see ~OutputQueue)
to model finite buffer, implement QoS and/or RED, and requests packets
from this external queue one-by-one.

In hosts, no such queue is used, so MAC contains an internal
queue named txQueue to queue up packets waiting for transmission.
Conceptually, txQueue is of infinite size, but for better diagnostics
one can specify a hard limit in the txQueueLimit parameter -- if this is
exceeded, the simulation stops with an error.


\tbf{Physical layer messaging}

Please see <a href="physical.html">Messaging on the physical layer</a>.

\tbf{Statistics}

Output vectors:
\begin{itemize}
\item txPkBytes: bytes sent, including Ethernet frame fields (but excluding preamble and SFD)
\item rxPkBytesOK: total bytes received  without collision or CRC error,
  including Ethernet frame fields (but excluding preamble and SFD)
\item passedUpPkBytes: number of bytes of frames actually passed up to higher layer
\item txPausePkUnits: number of PAUSE frames sent out
\item rxPausePkUnits: number of PAUSE frames received from network
\item rxPkBytesFromHL: number of bytes of frames received from higher layer
\item collision: number of collisions (NOT number of collided frames!) sensed
\item backoff: number of retransmissions
\item droppedPkBytesIfaceDown: number of bytes of frames from higher layer dropped
\item droppedPkBytesBitError: number of bytes of frames dropped because of bit errors
\item droppedPkBytesNotForUs: number of bytes of frames dropped because destination address didn't match
\end{itemize}

Output scalars (written in the finish() function) include the final values of
the above variables and throughput.

% FIXME prepareTxFrame padding should be performed before adding PREAMBLE_BYTES+SFD_BYTES

\subsection{EtherMAC}

Ethernet MAC layer. MAC performs transmission and reception of frames.
See the \nedtype{IEtherMAC} for the Ethernet MAC layer general informations.
Doesn't do encapsulation/decapsulation; see \nedtype{EtherLLC} and
\nedtype{EtherEncap} for that.

Supported variations:
\begin{itemize}
\item 10Mb Ethernet bus or twisted pair
\item 100Mb Ethernet duplex or half-duplex
\item 1Gb Ethernet
\end{itemize}

Supports all three Ethernet frame types. (It handles \msgtype{EtherFrame} message class;
specific frame classes (Ethernet-II, IEEE 802.3) are subclassed from that one.)
RAW mode (only used by the IPX protocol) is not supported.

\tbf{Operation}

Processing of frames received from higher layers:
\begin{itemize}
\item if src address in the frame is empty, fill it out
\item frames get queued up until transmission
\item transmit according to the CSMA/CD protocol
\item can send PAUSE message if requested by higher layers (PAUSE protocol,
  used in switches).
\end{itemize}

Processing of frames incoming from the network:
\begin{itemize}
\item receive according to the CSMA/CD protocol
\item CRC checking (frames with the error bit set are discarded).
\item respond to PAUSE frames
\item in promiscuous mode, pass up all received frames;
  otherwise, only frames with matching MAC addresses and
  broadcast frames are passed up.
\end{itemize}


\subsection{EtherMACFullDuplex}

Ethernet MAC which supports full duplex operation ONLY.
See the \nedtype{IEtherMAC} for general informations.

Most of today's Ethernet networks are switched, and operate
in full duplex mode. Full-duplex transmission can be used for
point-to-point connections only. Since full-duplex connections
cannot be shared, collisions are eliminated. This setup eliminates
most of the need for the CSMA/CD access control mechanism because
there is no need to determine whether the connection is already
being used. This allows for a much simpler simulation model
for MAC. (In "traditional" Ethernet simulations, most of the code
deals with the shared medium and the CSMA/CD mechanism.)
\nedtype{EtherMACFullDuplex} implements Ethernet without shared medium and CSMA/CD.
(If you need half-duplex operation, see \nedtype{EtherMAC} which is for a full-blown
and therefore more complicated Ethernet MAC model.)

\nedtype{EtherMACFullDuplex} performs transmission and reception of frames.
It does not do encapsulation/decapsulation; see \nedtype{EtherLLC} and
\nedtype{EtherEncap} for that.

Supported variations:
\begin{itemize}
\item 10Mb Ethernet (full duplex mode)
\item 100Mb Ethernet (full duplex mode)
\item 1Gb Ethernet (full duplex mode)
\end{itemize}

Supports all three Ethernet frame types. (It handles \msgtype{EtherFrame} message class;
specific frame classes (Ethernet-II, IEEE 802.3) are subclassed from that one.)
RAW mode (only used by the IPX protocol) is not supported.

\tbf{Operation}

Processing of frames received from higher layers:
\begin{itemize}
\item if src address in the frame is empty, fill it out
\item frames get queued up until transmission
\item transmit frames on the physical layer
\item can send PAUSE message if requested by higher layers (PAUSE protocol,
  used in switches).
\end{itemize}

Processing of frames incoming from the network:
\begin{itemize}
\item receive frames from physical layer
\item CRC checking (frames with the error bit set are discarded).
\item respond to PAUSE frames
\item in promiscuous mode, pass up all received frames;
  otherwise, only frames with matching MAC addresses and
  broadcast frames are passed up.
\end{itemize}

% TODO document notifications: NF_PP_TX_BEGIN, NF_PP_TX_END, NF_PP_RX_END

% FIXME full duplex does not need carrier extension

\subsection{Messaging on the Physical Layer}

Messages sent by \nedtype{EtherMAC} mark the beginning of a transmission.
The end of a transmission is not explicitly represented by a message,
but instead, the \nedtype{EtherMAC} calculates it from the frame length and
the transmission rate. Frames are represented by \msgtype{EtherFrame}.

When frames collide, the transmission is aborted -- in this case
\nedtype{EtherMAC} makes use of the modelled jam signals to figure out
when colliding transmissions end.

When a transmitting station senses a collision, it transmits a jam signal.
Jam signals are represented by a \msgtype{EtherJam} message.
When \nedtype{EtherMAC} received a jam signal, it knows that one transmission
has ended in jamming -- thus when it receives as many jam messages
as colliding frames, it can be sure all transmissions have been aborted.

Receiving a jam message marks the beginning (and not the end)
of a jam signal, so actually \nedtype{EtherMAC} has to wait for the duration
of the jamming before assuming the channel is free again.

\subsection{MAC and higher layers}

MAC and LLC are implemented as separate modules (\nedtype{EtherMAC} and
\nedtype{EtherLLC}/\nedtype{EtherEncap}) because encapsulation/decapsulation functionality
is not always needed. (Switches don't do encapsulation/decapsulation.)
In switches, \nedtype{EtherMAC} is used with \nedtype{MACRelayUnit}.

\subsection{PAUSE handling}
\label{pause_handling}

The 802.3x standard supports PAUSE frames as a means of flow
control. The frame contains a timer value, expressed as a multiple
of 512 bit-times, that specifies how long the transmitter should
remain quiet. If the receiver becomes uncongested before the
transmitter's pause timer expires, the receiver may elect to send
another Pause frame to the transmitter with a timer value of zero,
allowing the transmitter to resume immediately.

\nedtype{EtherMAC} will properly respond to PAUSE frames it receives
(\msgtype{EtherPauseFrame} class),
however it will never send a PAUSE frame by itself. (For one thing,
it doesn't have an input buffer that can overflow.)

\nedtype{EtherMAC}, however, transmits PAUSE frames received by higher layers,
and \nedtype{EtherLLC} can be instructed by a command to send a PAUSE frame to MAC.

\nedtype{MACRelayUnit} types (and thus \nedtype{EtherSwitch}) currently implement a very simple
scheme for sending PAUSE frames -- this can be refined if the need arises.

% FIXME PAUSE frames should only be sent on full-duplex ethernet.
%       If a switch uses half-duplex mode to connect to hosts, it can ask sending hosts
%       to slow down their sending rates:
%       - force collisions with incoming frames
%       - make it appear as if the channel is busy
% FIXME #351 dst address is not set in PAUSE frames -> dropped by receiving MAC (see checkDestinationAddress) ???
%            dst should be the special multicast address 01-80-C2-00-00-01 or the unicast address of the peer device
%            the address 01-80-C2-00-00-01 conforms to 802.1D: bridges will not forward frames sent to this address
% FIXME PAUSE frames should have 0x8808 in the etherType field

\subsection{Visual effects}


\section{Switches}

Ethernet switches play an important role in modern Ethernet LANs. Unlike
passive hubs and repeaters, that work in the physical layer, the switches
operate in the data link layer and routes data frames between the connected
subnets.

While a hub repeats the data frames on each connected line, possibly causing
collisions, switches help to segment the network to small collision domains.
In modern Gigabit LANs each node is connected to the switch direclty
by full-duplex lines, so no collisions are possible. In this case the
CSMA/CD is not needed and the channel utilization can be high.

\subsection{MAC relay units}

INET framework ethernet switches are built from \nedtype{IMACRelayUnit}
components. Each relay unit has N input and output gates for sending/receiving
Ethernet frames. They should be connected to \nedtype{IEtherMAC} modules.

Internally the relay unit holds a table for the destination address -> output
port mapping. When it receives a data frame it updates the table with the
source address->input port. The table can also be pre-loaded from a text file
while initializing the relay unit. The file name given as the \fpar{addressTableFile}
parameter. Each line of the file contains a hexadecimal MAC address and a decimal port
number separated by tabs. Comment lines beginning with '\#' are also allowed:

\begin{verbatim}
01 ff ff ff ff	0
00-ff-ff-ee-d1	1
0A:AA:BC:DE:FF	2
\end{verbatim}

% FIXME #352 addressTableSize is not checked in readAddressTable -> if overflown
%            then later check updateTableWithAddress has no effect
% FIXME format is wrong in the comment of readAddressTable()

The size of the lookup table is restricted by the \fpar{addressTableSize} parameter.
When the table is full, the oldest address is deleted. Entries are also deleted
if their age exceeds the duration given as the \fpar{agingTime} parameter.

If the destination address is not found in the table, the frame is broadcasted.
The frame is not sent to the same subnet it was received from, because the
target already received the original frame. The only exception if the frame
arrived through a radio channel, in this case the target can be out of range.
The port range 0..\fpar{numWirelessPorts}-1 are reserved for wireless connections.

The \nedtype{IMACRelayUnit} module is not a concrete implementation,
it just defines gates and parameters an \nedtype{IMACRelayUnit} should have.
Concrete inplementations add
capacity and performance aspects to the model (number of frames processed
per second, amount of memory available in the switch, etc.)
C++ implementations can subclass from the class \cppclass{MACRelayUnitBase}.

There are two versions of \nedtype{IMACRelayUnit}:

\begin{description}
  \item[\nedtype{MACRelayUnitNP}] models one or more CPUs with shared memory,
    working from a single shared queue.
  \item[\nedtype{MACRelayUnitPP}] models one CPU assigned to each incoming port,
    working with shared memory but separate queues.
\end{description}

In both models input messages are queued. CPUs poll messages from the queue
and process them in \fpar{processingTime}. If the memory usage exceeds
\fpar{bufferSize}, the frame will be dropped.

A simple scheme for sending PAUSE frames is built in (although
users will probably change it). When the buffer level goes
above a high watermark, PAUSE frames are sent on all ports.
The watermark and the pause time is configurable; use zero
values to disable the PAUSE feature.

% FIXME valid values for pauseTime: 0..0xFFFF
% FIXME ETHER_PAUSE_COMMAND_BYTES should be 4 in Ethernet.h (2bytes opcode + 2bytes pauseTime)
% FIXME #355 MACRelayUnitNP: pauseInterval calculation assumes 100Mb MAC (or 0.1Mb ???)
% FIXME PAUSE frame should not be sent on all ports probably
% TODO add lowWatermark, send PauseFrame(pauseUnits=0) to resume sending

The relay units collects the following statistics:

\begin{description}
\item[usedBufferBytes] memory usage as function of time
\item[processedBytes] count and length of processed frames
\item[droppedBytes] count and length of frames dropped caused by out of memory
\end{description}

% FIXME MACRelayUnitNP: no signals are generated, how does @statistic work in the ned file?

\subsection{EtherSwitch}

Model of an Ethernet switch containing a relay unit and multiple MAC units.

The duplexChannel attributes of the MACs must be set according to the
medium connected to the port; if collisions are possible (it's a bus or hub)
it must be set to false, otherwise it can be set to true.
By default it uses half duples MAC with CSMA/CD.

Spanning tree algorithm (used to prevent loops in the network) is not implemented.

\section{Link Layer Control}

% FIXME #353 there is no module for sending EtherFrameWithSNAP frames
% FIXME ETHER_SNAP_HEADER_LENGTH is wrong in Ethernet.h (+3 bytes, ssap+dsap+control)

\subsection{Frame types}

The raw 802.3 frame format header contains the MAC addresses of the destination and source
of the packet and the length of the data field. The frame footer contains the FCS
(Frame Check Sequence) field which is a 32-bit CRC.

\begin{center}
\begin{bytefield}[bitwidth=1.2em,bitheight=2\baselineskip]{20}
\bitbox{4}{\small MAC \\ destination} &
\bitbox{4}{\small MAC \\ source} &
\bitbox{4}{\small Length} &
\bitbox{4}{\small Payload} &
\bitbox{4}{\small FCS} \\
\bitbox{4}{\small 6 octets} &
\bitbox{4}{\small 6 octets} &
\bitbox{4}{\small 2 octets} &
\bitbox{4}{\small 46-1500 octets} &
\bitbox{4}{\small 4 octets}
\end{bytefield}
\end{center}

Each such frame is preceded by a 7 octet Preamble (with 10101010 octets) and
a 1 octet SFD (Start of Frame Delimiter) field (10101011) and followed by an
12 octet interframe gap. These fields are added and removed in the MAC layer,
so they are omitted here.

When multiple upper layer protocols use the same Ethernet line,
the kernel has to know which which component handles the incoming frames.
For this purpose a protocol identifier was added to the standard Ethernet
frames.

The first solution preceded the 802.3 standard and used a 2 byte protocol
identifier in place of the Length field. This is called Ethernet II
or DIX frame.
Each protocol id is above 1536, so the Ethernet II frames and the 802.3
frames can be distinguished.

\begin{center}
\begin{bytefield}[bitwidth=1.2em,bitheight=2\baselineskip]{20}
\bitbox{4}{\small MAC \\ destination} &
\bitbox{4}{\small MAC \\ source} &
\bitbox{4}{\small EtherType} &
\bitbox{4}{\small Payload} &
\bitbox{4}{\small FCS} \\
\bitbox{4}{\small 6 octets} &
\bitbox{4}{\small 6 octets} &
\bitbox{4}{\small 2 octets} &
\bitbox{4}{\small 46-1500 octets} &
\bitbox{4}{\small 4 octets}
\end{bytefield}
\end{center}

The LLC frame format uses a 1 byte source, a 1 byte destination, and a 1 byte
control information to identify the encapsulated protocol adopted from the
802.2 standard. These fields follow the standard 802.3 header, so the maximum
length of the payload is 1497 bytes:

\begin{center}
\begin{bytefield}[bitwidth=1.2em,bitheight=2\baselineskip]{20}
\bitbox{4}{\small MAC \\ destination} &
\bitbox{4}{\small MAC \\ source} &
\bitbox{4}{\small Length} &
\bitbox{4}{\small DSAP} &
\bitbox{4}{\small SSAP} &
\bitbox{4}{\small Control} &
\bitbox{4}{\small Payload} &
\bitbox{4}{\small FCS} \\
\bitbox{4}{\small 6 octets} &
\bitbox{4}{\small 6 octets} &
\bitbox{4}{\small 2 octets} &
\bitbox{4}{\small 1 octets} &
\bitbox{4}{\small 1 octets} &
\bitbox{4}{\small 1 octets} &
\bitbox{4}{\small 43-1497 octets} &
\bitbox{4}{\small 4 octets}
\end{bytefield}
\end{center}

The SNAP header uses the EtherType protocol identifiers inside an LLC header.
The SSAP and DSAP fields are filled with 0xAA (SAP\_SNAP), and the control
field is 0x03. They are followed by a 3 byte orgnaization and a 2 byte local
code the identify the protocol. If the organization code is 0, the local field
contains an EtherType protocol identifier.

\begin{center}
\begin{bytefield}[bitwidth=1.2em,bitheight=2\baselineskip]{20}
\bitbox{4}{\small MAC \\ destination} &
\bitbox{4}{\small MAC \\ source} &
\bitbox{4}{\small Length} &
\bitbox{4}{\small DSAP \\ 0xAA} &
\bitbox{4}{\small SSAP \\ 0xAA} &
\bitbox{4}{\small Control \\ 0x03} &
\bitbox{4}{\small OrgCode} &
\bitbox{4}{\small Local \\ Code} &
\bitbox{4}{\small Payload} &
\bitbox{4}{\small FCS} \\
\bitbox{4}{\small 6 octets} &
\bitbox{4}{\small 6 octets} &
\bitbox{4}{\small 2 octets} &
\bitbox{4}{\small 1 octets} &
\bitbox{4}{\small 1 octets} &
\bitbox{4}{\small 1 octets} &
\bitbox{4}{\small 3 octets} &
\bitbox{4}{\small 2 octets} &
\bitbox{4}{\small 38-1492 octets} &
\bitbox{4}{\small 4 octets}
\end{bytefield}
\end{center}

The INET defines these frames in the \ffilename{EtherFrame.msg} file.
The models supports Ethernet II, 803.2 with LLC header, and 803.3 with LLC and SNAP headers.
The corresponding classes are:
\msgtype{EthernetIIFrame}, \msgtype{EtherFrameWithLLC} and \msgtype{EtherFrameWithSNAP}. They all class
from \msgtype{EtherFrame} which only represents the basic MAC frame with source and
destination addresses. \nedtype{EtherMAC} only deals with \msgtype{EtherFrame}s, and does not
care about the specific subclass.

Ethernet frames carry data packets as encapsulated cMessage objects.
Data packets can be of any message type (cMessage or cMessage subclass).

The model encapsulates data packets in Ethernet frames using the \ttt{encapsulate()}
method of cMessage. Encapsulate() updates the length of the Ethernet frame too,
so the model doesn't have to take care of that.

The fields of the Ethernet header are passed in a \cppclass{Ieee802Ctrl}
control structure to the LLC by the network layer.


EtherJam, EtherPadding (interframe gap), EtherPauseFrame?


\subsection{EtherEncap}

The \nedtype{EtherEncap} module generates \msgtype{EthernetIIFrame} messages.

EtherFrameII

\subsection{EtherLLC}

EtherFrameWithLLC

SAP registration

% TODO delete EtherLLC, because LLC without SNAP is not used with IP (no ARP,IPv6 SAP)
% TODO modify EtherEncap to handle EtherFrameWithSNAP frames too (we can not send EtherFrameWithSNAP now)

\subsubsection{\nedtype{EtherLLC} and higher layers}

The \nedtype{EtherLLC} module can serve several applications (higher layer protocols),
and dispatch data to them. Higher layers are identified by DSAP.
See section "Application registration" for more info.

\nedtype{EtherEncap} doesn't have the functionality to dispatch to different
higher layers because in practice it'll always be used with IP.

\subsubsection{Communication between LLC and Higher Layers}

Higher layers (applications or protocols) talk to the \nedtype{EtherLLC} module.

When a higher layer wants to send a packet via Ethernet, it just
passes the data packet (a cMessage or any subclass) to \nedtype{EtherLLC}.
The message kind has to be set to IEEE802CTRL\_DATA.

In general, if \nedtype{EtherLLC} receives a packet from the higher layers,
it interprets the message kind as a command. The commands include
IEEE802CTRL\_DATA (send a frame), IEEE802CTRL\_REGISTER\_DSAP (register highher layer)
IEEE802CTRL\_DEREGISTER\_DSAP (deregister higher layer) and IEEE802CTRL\_SENDPAUSE
(send PAUSE frame) -- see EtherLLC for a more complete list.

The arguments to the command are NOT inside the data packet but
in a "control info" data structure of class \cppclass{Ieee802Ctrl}, attached to
the packet. See controlInfo() method of cMessage (OMNeT++ 3.0).

For example, to send a packet to a given MAC address and protocol
identifier, the application sets the data packet's message kind
to ETH\_DATA ("please send this data packet" command),
fills in the \nedtype{Ieee802Ctrl} structure with the destination MAC address and
the protocol identifier, adds the control info to the message, then sends
the packet to \nedtype{EtherLLC}.

When the command doesn't involve a data packet (e.g.
IEEE802CTRL\_(DE)REGISTER\_DSAP, IEEE802CTRL\_SENDPAUSE), a dummy packet
(empty cMessage) is used.

\subsubsection{Rationale}

The alternative of the above communications would be:

\begin{itemize}
  \item adding the parameters such as destination address into the data
    packet. This would be a poor solution since it would make the
    higher layers specific to the Ethernet model.
  \item encapsulating a data packet into an \textit{interface packet} which
    contains the destination address and other parameters. The
    disadvantages of this approach is the overhead associated with
    creating and destroying the interface packets.
\end{itemize}

Using a control structure is more efficient than the interface packet
approach, because the control structure can be created once inside
the higher layer and be reused for every packet.

It may also appear to be more intuitive in Tkenv because one can observe
data packets travelling between the higher layer and Ethernet
modules -- as opposed to "interface" packets.


\subsubsection{EtherLLC: SAP Registration}

The Ethernet model supports multiple applications or higher layer
protocols.

So that data arriving from the network can be dispatched to the
correct applications (higher layer protocols), applications
have to register themselves in \nedtype{EtherLLC}. The registration
is done with the IEEE802CTRL\_REGISTER\_DSAP command
(see section "Communication between LLC and higher layers")
which associates a SAP with the LLC port. Different applications
have to connect to different ports of \nedtype{EtherLLC}.

The ETHERCTRL\_REGISTER\_DSAP/IEEE802CTRL\_DEREGISTER\_DSAP commands use only the
dsap field in the \cppclass{Ieee802Ctrl} structure.

\subsection{EthernetInterface module}

The \nedtype{EthernetInterface} compound module implements the \nedtype{IWiredNic}
interface. Complements \nedtype{EtherMAC} and \nedtype{EtherEncap} with an output queue
for QoS and RED support. It also has configurable input/output filters as \nedtype{IHook}
components similarly to the \nedtype{PPPInterface} module.

% TODO there is no IWiredNic with EtherLLC

\section{Ethernet applications}

The \nedtype{inet.applications.ethernet} package contains modules
for a simple client-server application. The \nedtype{EtherAppCli} is a simple
traffic generator that peridically sends \msgtype{EtherAppReq} messages
whose length can be configured. destAddress, startTime,waitType, reqLength, respLength

The server component of the model (\nedtype{EtherAppSrv}) responds with a
\msgtype{EtherAppResp} message of the requested length. If the response does
not fit into one ethernet frame, the client receives the data in multiple
chunks.

% FIXME reqLength>1500 causes an error in the LLC module
% FIXME numFrames field of EtherAppRes is not used
% FIXME server always sends 1497 byte chunks, it should depend on the framing (1497 is for LLC)
% FIXME if registerSAP is false (default), the and EtherLLC used, then the client won't receive messages (auto config?)
% FIXME Ieee802Nic -> EthernetInterface in the NED comment

Both applications have a \fpar{registerSAP} boolean parameter.
This parameter should be set to \ttt{true} if the application is connected
to the \nedtype{EtherLLC} module which requires registration of the SAP
before sending frames.

Both applications collects the following statistics: sentPkBytes, rcvdPkBytes,
endToEndDelay.

The client and server application works with any model that accepts
Ieee802Ctrl control info on the packets (e.g. the 802.11 model).
The applications should be connected directly to the \nedtype{EtherLLC}
or an EthernetInterface NIC module.

The model also contains a host component that groups the applications
and the LLC and MAC components together (\nedtype{EtherHost}). This node does
not contain higher layer protocols, it generates Ethernet traffic directly.
By default it is configured to use half duplex MAC (CSMA/CD).

\section{Ethernet networks}

\subsection{\nedtype{LargeNet} model}

The \nedtype{LargeNet} model demonstrates how one can put together models of large
LANs with little effort, making use of MAC auto-configuration.

\nedtype{LargeNet} models a large Ethernet campus backbone. As configured in the
default omnetpp.ini, it contains altogether about 8000 computers
and 900 switches and hubs. This results in about 165MB process size
on my (32-bit) linux box when I run the simulation.
The model mixes all kinds of Ethernet technology: Gigabit Ethernet,
100Mb full duplex, 100Mb half duplex, 10Mb UTP, 10Mb bus ("thin Ethernet"),
switched hubs, repeating hubs.

The topology is in \nedtype{LargeNet}.ned, and it looks like this: there's chain
of n=15 large "backbone" switches (switchBB[]) as well as four more
large switches (switchA, switchB, switchC, switchD) connected to
somewhere the middle of the backbone (switchBB[4]). These 15+4 switches
make up the backbone; the n=15 number is configurable in omnetpp.ini.

Then there're several smaller LANs hanging off each backbone switch.
There're three types of LANs: small, medium and large (represented by
compound module types \nedtype{SmallLAN}, \nedtype{MediumLAN}, \nedtype{LargeLAN}). A small LAN
consists of a few computers on a hub (100Mb half duplex); a medium
LAN consists of a smaller switch with a hub on one of its port
(and computers on both); the large one also has a switch and a hub,
plus an Ethernet bus hanging of one port of the hub (there's still hubs
around with one BNC connector besides the UTP ones).
By default there're 5..15 LANs of each type hanging off each backbone
switch. (These numbers are also omnetpp.ini parameters like the length
of the backbone.)

The application model which generates load on the simulated LAN is
simple yet powerful. It can be used as a rough model for any
request-response based protocol such as SMB/CIFS (the Windows file
sharing protocol), HTTP, or a database client-server protocol.

Every computer runs a client application (\nedtype{EtherAppCli}) which connects
to one of the servers. There's one server attached to switches A, B,
C and D each: serverA, serverB, serverC and serverD -- server selection
is configured in omnetpp.ini). The servers run \nedtype{EtherAppSrv}.
Clients periodically send a request to the server, and the request
packet contains how many bytes the client wants the server to send back
(this can mean one or more Ethernet frames, depending on the byte count).
 Currently the request and reply lengths are configured in omnetpp.ini
as intuniform(50,1400) and truncnormal(5000,5000).

The volume of the traffic can most easily be controlled with the
time period between sending requests; this is currently
set in omnetpp.ini to exponential(0.50) (that is, average 2
requests per second). This already causes frames to be dropped
in some of the backbone switches, so the network is a bit
overloaded with the current settings.

The model generates extensive statistics. All MACs (and most other
modules too) write statistics into omnetpp.sca at the end
of the simulation: number of frames sent, received, dropped, etc.
These are only basic statistics, however it still makes the
scalar file to be several ten megabytes in size. You can use
the analysis tools provided with OMNeT++ to visualized the data
in this file. (If the file size is too big, writing statistics
can be disabled, by putting **.record-scalar=false in the ini file.)
The model can also record output vectors, but this is currently
disabled in omnetpp.ini because the generated file can easily reach
gigabyte sizes.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:
