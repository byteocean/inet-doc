\chapter{IPv4}
\label{cha:ipv4}


\section{Overview}

routing

fragmentation

options

\subsection{Implemented standards}

\begin{itemize}
  \item RFC791: Internet Protocol
  \item RFC792: Internet Control Message Protocol
  \item RFC826: Address Resolution Protocol
  \item RFC903: A Reverse Address Resolution Protocol
  \item RFC1122: Requirements for Internet Hosts - Communication Layers
%  \item RFC1868: ARP Extension -- UNARP
\end{itemize}


\subsection{INET modules}

TODO list the modules: IP, ICMP, RoutingTable, etc.

\section{The IP Module}

The \nedtype{IP} module implements the IPv4 protocol.

For connecting the upper layer protocols the \nedtype{IP} module
has \emph{transportIn[]} and \emph{transportOut[]} gate vectors.
Usually the TCP connected to the gate 0, UDP to gate 1, ICMP to
gate 2, IGMP to gate 3, and RSVP to gate 4.

The IP packets are sent to the \nedtype{ARP} module through the
\emph{queueOut} gate. The incoming IP packets are received
directly from the network interface cards through the
\emph{queueIn[]} gates. Each interface card knows its own
network layer gate index.

\subsection{IP packets}

IP packets, IP header

\begin{center}
\begin{bytefield}{32}
\bitheader{0,3,4,7,8,15,16,18,19,23,24,31} \\
\bitbox{4}{Version} &
\bitbox{4}{IHL} &
\bitbox{8}{\small Type of Service} &
\bitbox{16}{Total Length} \\
\bitbox{16}{Identification} &
\bitbox{3}{Flags} &
\bitbox{13}{Fragment Offset} \\
\bitbox{8}{Time to Live} &
\bitbox{8}{Protocol} &
\bitbox{16}{Header Checksum} \\
\bitbox{32}{Source Address} \\
\bitbox{32}{Destination Address} \\
\bitbox{24}{Options} &
\bitbox{8}{Padding} \\
\end{bytefield}
\end{center}

description of the fields

An IP datagram is represented by the \cppclass{IPDatagram} message class.

control info: \cppclass{IPv4ControlInfo}, \cppclass{IPv4RoutingDecision}

\subsection{Sending and receiving packets}

\subsection{Routing}


\subsection{Parameters}

\begin{itemize}
  \item \fpar{procDelay}
  \item \fpar{timeToLive}
  \item \fpar{multicastTimeToLive}
  \item \fpar{protocolMapping}
  \item \fpar{fragmentTimeout}
  \item \fpar{forceBroadcast}
\end{itemize}

% \subsection{Sending a packet over IP}
% 
% To send a packet over IP from a higher layer protocol, the module should
% fill in an \cppclass{IPControlInfo} object, attach it to the packet with
% \cppclass{cMessage}'s \ttt{setControlInfo()} method, the send it to the IP
% module.
% 
% When IP sends up a packet to a higher layer protocol, it will also attach
% an \cppclass{IPControlInfo} to the packet, with the source and destination
% IP address, etc. of the IP datagram in which the packet arrived.
% 
% IP can serve several higher-layer protocols. When delivering packets to
% them, the output gate is determined from the Protocol field in the IP
% header. The protocol-to-gateindex mapping must be given in the
% \ttt{protocolMapping} string parameter, in the following format:
% 
% \begin{verbatim}
% protocolnumber:gateindex, protocolnumber:gateindex, ...
% \end{verbatim}
% 
% The recommended setting is:
% 
% \begin{itemize}
%   \item TCP (6) : 0
%   \item UDP (17) : 1
%   \item ICMP (1) : 2
%   \item IGMP (2) : 3
%   \item RSVP (46) : 4
% \end{itemize}
% 
% That is, \ttt{protocolMapping} should be set to \ttt{"6:0,17:1,1:2,2:3,46:4"}.

\subsection{Routing, and interfacing with lower layers}

The routing table is stored in the module \nedtype{RoutingTable}. When a
datagram needs to be routed, IP queries \nedtype{RoutingTable} for the
output interface (or "port") and next hop address of the packet. This is
done by directly calling C++ methods (such as
\ttt{findBestMatchingRoute(destAddress)}) of \nedtype{RoutingTable}. No
message exchange with \nedtype{RoutingTable} takes place.

A routed datagram will be sent to the \ttt{queueOut} gate with an
\cppclass{IPRoutingDecision} control info object attached to it, which
contains the next hop address and the output interface number.
\ttt{queueOut} is expected to be connected to \nedtype{ARP}.

Routing protocol implementations can query and manipulate the route table
by calling \nedtype{RoutingTable}'s C++ methods.

% \subsection{Performance model, QoS}
% 
% In the current form, IP contains a FIFO which queues up IP datagrams;
% datagrams are processed in order. The processing time is determined by the
% \ttt{procDelay} module parameter.
% 
% The current performance model comes from the \cppclass{QueueBase} C++ base
% class. If you need a more sophisticated performance model, you may change
% the module implementation (the IP class), and: (1) override the
% startService() method which determines processing time for a packet, or (2)
% use a different base class.

\section{The RoutingTable module}

The \nedtype{RoutingTable} module does not have any connections,
it is accessed by direct method calls instead.

The routing table is modified by routing algorithms (FlatNetworkConfigurator, OSPF, Manet, bgpv4).
Static routes can be described by a text file. Read in stage 1.

The routing table queried by the \nedtype{IP} module for routing decisions.

Methods:

\begin{itemize}
  \item \ffunc{getInterfaceForDestAddress}
  \item \ffunc{getGatewayForDestAddress}
  \item \ffunc{findBestMatchingRoutes}
  \item \ffunc{getMulticastRoutesFor}
\end{itemize}

% addRoute/deleteRoute

Parameters:

\begin{itemize}
  \item \fpar{routerId}: for routers, the router id using IPv4 address dotted notation;
        specify ``auto'' to select the highest interface address; should be left empty ``''
        for hosts
  \item \fpar{IPForward}: turns IP forwarding on/off
  \item \fpar{routingFile}: routing table file name
\end{itemize}

\subsection{The IP routing files}

Routing files are files with \ttt{.irt} or \ttt{.mrt} extension,
and their names are passed in the routingFileName parameter
to RoutingTable modules. RoutingTables are present in all
IP nodes (hosts and routers).

Routing files may contain network interface configuration and static
routes. Both are optional. Network interface entries in the file
configure existing interfaces; static routes are added to the route table.

Interfaces themselves are represented in the simulation by modules
(such as the PPP module). Modules automatically register themselves
with appropriate defaults in the RoutingTable, and entries in the
routing file refine (overwrite) these settings.
Interfaces are identified by names (e.g. ppp0, ppp1, eth0) which
are normally derived from the module's name: a module called
\ttt{"ppp[2]"} in the NED file registers itself as interface ppp2.

An example routing file (copied here from one of the example simulations):

\begin{verbatim}
ifconfig:

# ethernet card 0 to router
name: eth0   inet_addr: 172.0.0.3   MTU: 1500   Metric: 1  BROADCAST MULTICAST
Groups: 225.0.0.1:225.0.1.2:225.0.2.1

# Point to Point link 1 to Host 1
name: ppp0   inet_addr: 172.0.0.4   MTU: 576   Metric: 1

ifconfigend.

route:
172.0.0.2   *           255.255.255.255  H  0   ppp0
172.0.0.4   *           255.255.255.255  H  0   ppp0
default:    10.0.0.13   0.0.0.0          G  0   eth0

225.0.0.1   *           255.255.255.255  H  0   ppp0
225.0.1.2   *           255.255.255.255  H  0   ppp0
225.0.2.1   *           255.255.255.255  H  0   ppp0

225.0.0.0   10.0.0.13   255.0.0.0        G  0   eth0

routeend.
\end{verbatim}

The \ttt{ifconfig...ifconfigend.} part configures interfaces,
and \ttt{route..routeend.} part contains static routes.
The format of these sections roughly corresponds to the output
of the \ttt{ifconfig} and \ttt{netstat -rn} Unix commands.

An interface entry begins with a \ttt{name:} field, and lasts until
the next \ttt{name:} (or until \ttt{ifconfigend.}). It may
be broken into several lines.

Accepted interface fields are:

\begin{itemize}
  \item \ttt{name:} - arbitrary interface name (e.g. eth0, ppp0)
  \item \ttt{inet\_addr:} - IP address
  \item \ttt{Mask:} - netmask
  \item \ttt{Groups:} Multicast groups. 224.0.0.1 is added automatically,
     and 224.0.0.2 also if the node is a router (IPForward==true).
  \item \ttt{MTU:} - MTU on the link (e.g. Ethernet: 1500)
  \item \ttt{Metric:} - integer route metric
  \item flags: \ttt{BROADCAST}, \ttt{MULTICAST}, \ttt{POINTTOPOINT}
\end{itemize}

The following fields are parsed but ignored: \ttt{Bcast},\ttt{encap},
\ttt{HWaddr}.

Interface modules set a good default for MTU, Metric (as 2e9/bitrate) and
flags, but leave inet\_addr and Mask empty. inet\_addr and mask should
be set either from the routing file or by a dynamic network configuration
module.

The route fields are:

\begin{verbatim}
Destination  Gateway  Netmask  Flags  Metric Interface
\end{verbatim}

\textit{Destination}, \textit{Gateway} and \textit{Netmask} have the usual meaning.
The \textit{Destination} field should either be an IP address or "default:"
(to designate the default route). For \textit{Gateway}, \ttt{*} is also
accepted with the meaning \ttt{0.0.0.0}.

\textit{Flags} denotes route type:

\begin{itemize}
  \item \textit{H} "host": direct route (directly attached to the router), and
  \item \textit{G} "gateway": remote route (reached through another router)
\end{itemize}

\textit{Interface} is the interface name, e.g. \ttt{eth0}.



\section{The ICMP module}

The Internet Control Message Protocol (ICMP) is the error reporting and
diagnostic mechanism of the Internet.
It uses the services of IP, so it is a transport layer protocol, but unlike
TCP or UDP it is not used to transfer user data. It can not be separated
from the IP, because the routing errors are reported by ICMP.

The \nedtype{ICMP} module can be used to send error messages and ping
request. It can also respond to incoming ICMP messages.

Each ICMP message is encapsulated within an IP datagram, so its delivery
is unreliable.

\begin{center}
\begin{bytefield}{32}
\bitheader{0,7,8,15,31} \\
\bitbox{8}{Type} &
\bitbox{8}{Code} &
\bitbox{16}{Checksum} \\
\bitbox{32}{Rest of header} \\
\wordbox{2}{Internet Header + 8 bytes of Original Datagram}
\end{bytefield}
\end{center}

The corresponding message class (\msgtype{ICMPMessage}) contains only
the Type and Code fields. The message encapsulates the IP packet that 
triggered the error, or the data of the ping request/reply.

% FIXME type=PARAMETER_PROBLEM, code=0: missing Pointer field from ICMPMessage
%            REDIRECT: Gateway Internet Address
%            ECHO_REQUEST, ECHO_REPLY: Identifier, Sequence Number
%            TIMESTAMP_REQUEST, TIMESTAMP_REPLY: Identifier, Sequence Number, Originate Timestamp, Receive Timestamp, Transmit Timestamp

% FIXME wrong type codes for ICMP_DESTINATION_UNREACHABLE (3), ICMP_ECHO_REQUEST (8), ICMP_ECHO_REPLY (0), ICMP_TIMESTAMP_REQUEST (13), ICMP_TIMESTAMP_REPLY (14)

The \nedtype{ICMP} module has two methods which can be used by other modules
to send ICMP error messages:
\begin{itemize}
  \item \ffunc[sendErrorMessage]{sendErrorMessage(IPv4Datagram*, ICMPType, ICMPCode)}
        used by the network layer to report erronous IPv4 datagrams. The ICMP header
        fields are set to the given type and code, and the ICMP message will encapsulate
        the given datagram.
  \item \ffunc[sendErrorMessage]{sendErrorMessage(cPacket*, IPv4ControlInfo*, ICMPType, ICMPCode)}
        used by the transport layer components to report erronous packets. The transport
        packet will be encapsulated into an IP datagram before wrapping it into the ICMP message.
\end{itemize}

The \nedtype{ICMP} module can be accessed from other modules of the node by calling
\ffunc{ICMPAccess::get()}.

When an incoming ICMP error message is received, the \nedtype{ICMP} module
sends it out on the \ttt{errorOut} gate unchanged. It is assumed that an
external module is connected to \ttt{errOut} that can process the error
packet. There is a simple module (\nedtype{ErrorHandling}) that simply
logs the error and drops the message. Note that the \nedtype{IPv4} module
does not send REDIRECT, DESTINATION\_UNREACHABLE,
TIME\_EXCEEDED and PARAMETER\_PROBLEM messages to the \nedtype{ICMP} module,
it will send them to the transport layer module that sent the bogus
packet encapsulated in the ICMP message.
\begin{note}
ICMP protocol encapsulates only the IP header + 8 byte following the IP header
from the bogus IP packet. The ICMP packet length computed from this truncated
packet, despite it encapsulates the whole IP message object.
As a consequence, calling \ffunc{decapsulate()} on the ICMP message
will cause an ``packet length became negative'' error. To avoid this,
use \ffunc{getEncapsulatedMsg()} to access the IP packet that caused the ICMP
error. 
\end{note}

The \nedtype{ICMP} module receives ping commands on the \ttt{pingIn}
gate from the application. The ping command can be any packet
having an \cppclass{IPv4ControlInfo} control info. The packet
will be encapsulated with an \msgtype{ICMPMessage} and
handed over to the IP.

If \nedtype{ICMP} receives an echo request from IP, the original
message object will be returned as the echo reply. Of course,
before sending back the object to IP, the source and destination
addresses are swapped and the message type changed to ICMP\_ECHO\_REPLY.

When an ICMP echo reply received, the application message decapsulated
from it and passed to the application through the \ttt{pingOut} gate.
The \cppclass{IPv4ControlInfo} also copied from the \msgtype{ICMPMessage}
to the application message. 

% FIXME ICMP TIMESTAMP requests are processed as ECHO requests

% \section{The IGMP module}

\section{The ARP module}

The \nedtype{ARP} module implements the Address Resolution Protocol (RFC826).
The ARP protocol is designed to translate a local protocol address
to a hardware address. Altough the ARP protocol can be used with
several network protocol and hardware addressing schemes, in practice
they are almost always IPv4 and 802.3 addresses. The INET implementation
of the ARP protocol (the \nedtype{ARP} module) supports only
IP address $\rightarrow$ MAC address translation. 

If a node wants to send an IP packet to a node whose MAC address is unknown,
it broadcasts an ARP frame on the Ethernet network.
In the request its publish its own IP and
MAC addresses, so each node in the local subnet can update their mapping.
The node whose MAC address was requested will respond with an ARP frame
containing its own MAC address directly to the node that sent the
request. When the original node receives the ARP response, it updates 
its ARP cache and sends the delayed IP packet using the learned MAC address.

The frame format of the ARP request and reponse is shown in Figure \ref{fig:ARP_frame}.
In our case the HTYPE (hardware type), PTYPE (protocol type), HLEN (hardware address length)
and PLEN (protocol address length) are constants: HTYPE=Ethernet (1), PTYPE=IPv4 (2048), HLEN=6,
PLEN=4. The OPER (operation) field is 1 for an ARP request and 2 for an ARP response.
The SHA field contains the 48-bit hardware address of the sender, SPA field is
the 32-bit IP address of the sender; THA and TPA are the addresses of the target.
The message class corresponding to the ARP frame is \msgtype{ARPPacket}.
In this class only the OPER, SHA, SPA, THA and TPA fields are stored.
The length of an \msgtype{ARPPacket} is 28 bytes.

\begin{figure}[h]
\begin{center}
\label{fig:ARP_frame}
\begin{bytefield}{16}
\bitheader{0,7,8,15} \\
\bitbox{16}{HTYPE} \\
\bitbox{16}{PTYPE} \\
\bitbox{8}{HLEN} &
\bitbox{8}{PLEN} \\
\bitbox{16}{OPER} \\
\wordbox{3}{SHA} \\
\wordbox{2}{SPA} \\
\wordbox{3}{THA} \\
\wordbox{2}{TPA} \\
\end{bytefield}
\caption{ARP frame}
\end{center}
\end{figure}

The \nedtype{ARP} module receives IP datagrams and ARP responses from \nedtype{IPv4}
on the \ttt{ipIn} gate and transmits IP datagrams and ARP requests on the \ttt{nicOut[]} gates
towards the network interface cards. ARP broadcasts the requests on the local network,
so the NIC's entry in the \nedtype{InterfaceTable} should have \ffunc{isBroadcast()} flag
set in order to participate in the address resolution.

The incoming IP packet should have an attached \cppclass{IPv4RoutingDecision} control
info containing the IP address of the next hop. If the hardware address is found
in the ARP cache, then the packet is transmitted to the addressed interface immediately.
Otherwise the packet is queued and an address resolution takes place.
The \nedtype{ARP} module creates an \msgtype{ARPPacket} object, sets the sender
MAC and IP address to its own address, sets the destination IP address
to the address of the target of the IP datagram, leave the destination MAC address
blank and broadcasts the packet on each network interface with broadcast capability.
Before sending the ARP packet, it retransmission a timer. If the timer expires,
it will retransmit the ARP request, until the maximum retry count is reached.
If there is no response to the ARP request, then the address resolution fails,
and the IP packet is dropped from the queue. Otherwise the MAC address of the
destination is learned and the IP packet can be transmitted on the corresponding
interface.

When an ARP packet is received on the \ttt{ipIn} gate, and the sender's IP
is already in the ARP cache, it is updated with the information in the ARP frame.
Then it is checked that the destination IP of the packet matches with our
address. In this case a new entry is created with the sender addresses in the
ARP cache, and if the packet is a request a response is created and sent directly
to the originator. If proxy ARP is enabled, the request can be responded
with our MAC address if we can route IP packets to the destination.

Usually each \nedtype{ARP} module maintains a local ARP cache.
However it is possible to use a global cache. The global cache is filled
in with entries of the IP and MAC addresses of the known interfaces
when the ARP modules are initiated (at simulation time 0).
\nedtype{ARP} modules that are using the global ARP cache
never initiate an address resolution; if an IP address not
found in the global cache, the simulation stops with an error.
However they will respond to ARP request, so the simulation can
be configured so that some \nedtype{ARP}s use local, while others
the global cache.

When an entry is inserted or updated in the local ARP cache,
the simulation time saved in the entry. The mapping in the
entry is not used after the configured \fpar{cacheTimeout}
elapsed. This parameter does not affect the entries of
the global cache however.

% FIXME why the global cache is cleared when an ARP module is deleted?

The module parameters of \nedtype{ARP} are:

\begin{itemize}
  \item \fpar{retryTimeout}: number of seconds ARP waits between retries to resolve an IPv4 address (default is 1s)
  \item \fpar{retryCount}: number of times ARP will attempt to resolve an IPv4 address (default is 3)
  \item \fpar{cacheTimeout}: number of seconds unused entries in the cache will time out (default is 120s)
  \item \fpar{proxyARP}: enables proxy ARP mode (default is \fkeyword{true})
  \item \fpar{globalARP}: use global ARP cache (default is \fkeyword{false})
\end{itemize}

The \nedtype{ARP} module emits four signals:

\begin{itemize}
  \item \ttt{sentReq}: emits 1 each time an ARP request is sent
  \item \ttt{sentReplies}: emits 1 each time an ARP response is sent
  \item \ttt{initiatedResolution}: emits 1 each time an ARP resolution is initiated 
  \item \ttt{failedResolution}: emits 1 each time an ARP resolution is failed
\end{itemize}

These signals are recorded as vectors and their counts as scalars.

% TODO watches, animation effects

\section{The IGMP module}


\section{The NetworkLayer module}

compound module: IP, ICMP, ErrorHandling, IGMP, ARP

\section{Applications}

They can be used with both IPv4 and IPv6.

\subsection{IP traffic generators}

Traffic generators that connect directly to IP (without using TCP or UDP):
\nedtype{IIPvXTraffixGenerator} (prototype).
 \nedtype{IPvXTrafGen},

Sends IP or IPv6 datagrams to the given address at the given \fpar{sendInterval}.
The \fpar{sendInterval} parameter can be a constant or a random value (e.g. exponential(1)).
If the \fpar{destAddresses} parameter contains more than one address, one
of them is randomly for each packet. An address may be given in the
dotted decimal notation (or, for IPv6, in the usual notation with colons),
or with the module name. (The \cppclass{IPvXAddressResolver} class is used to resolve
the address.) To disable the model, set destAddresses to "".

The \nedtype{IPvXTrafGen} sends messages with length \fpar{packetLength}.
The sent packet is emitted in the \fsignal{sentPk} signal.
The length of the sent packets can be recorded as scalars and vectors.

% FIXME packetLength declared as volatile, but in fact it is not.

The \nedtype{IPvXTrafSink} can be used as a receiver of the packets
generated by the traffic generator. This module emits the packet
in the \fsignal{rcvdPacket} signal and drops it. The \ttt{rcvdPkBytes}
and \ttt{endToEndDelay} statistics are generated from this signal.

The \nedtype{IPvXTrafGen} can also be the peer of the traffic generators;
it handles the received packets exactly like \nedtype{IPvXTrafSink}.

You can see an example usage of these applications in \ffilename{examples/inet/routerperf/omnetpp.ini}
simulaton.

\subsection{The PingApp application}

The \nedtype{PingApp} application
generates ping requests and calculates the packet loss and round trip
parameters of the replies.

Start/stop time, sendInterval etc. can be specified via parameters. An address
may be given in the dotted decimal notation (or, for IPv6, in the usual
notation with colons), or with the module name.
(The \cppclass{IPvXAddressResolver} class is used to resolve the address.)
To disable send, specify empty destAddr.

Every ping request is sent out with a sequence number, and replies are
expected to arrive in the same order. Whenever there's a jump in the
in the received ping responses' sequence number (e.g. 1, 2, 3, 5), then
the missing pings (number 4 in this example) is counted as lost.
Then if it still arrives later (that is, a reply with a sequence number
smaller than the largest one received so far) it will be counted as
out-of-sequence arrival. So the number of really lost pings will be
"lost" minus "out-of-order" (assuming there's no duplicate or bogus reply).

Uses \msgtype{PingPayload} as payload for the ICMP(v6) Echo Request/Reply packets.

\subsubsection*{Parameters}

\begin{itemize}
  \item \fpar{destAddr}: destination address
  \item \fpar{srcAddr}: source address (useful with multi-homing)
  \item \fpar{packetSize}: of ping payload, in bytes (default is 56)
  \item \fpar{sendInterval}: time to wait between pings (can be random, default is 1s)
  \item \fpar{hopLimit}: TTL or hopLimit for IP packets (default is 32)
  \item \fpar{count}: stop after \fpar{count} ping request, 0 means continuously
  \item \fpar{startTime}: send first ping request at \fpar{startTime}
  \item \fpar{stopTime}: time of finish sending, 0 means forever
  \item \fpar{printPing}: dump on stdout (default is \fkeyword{true})
\end{itemize}

\subsubsection*{Signals and Statistics}

\begin{itemize}
  \item \fsignal{endToEndDelay} value of the round trip time
  \item \fsignal{drop} number of dropped packets
  \item \fsignal{outOfOrderArrival} number of packets arrived out-of-order
  \item \fsignal{pingTx} sequence number of the sent ping request
  \item \fsignal{pingRx} sequence number of the received ping response
\end{itemize}

\ttt{pingRTT} stat

% FIXME seqNo should be part of ICMPMessage

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:

