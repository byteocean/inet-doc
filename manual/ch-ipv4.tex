\chapter{IPv4}
\label{cha:ipv4}


\section{Overview}

TODO list the modules: IP, ICMP, RoutingTable, etc.


\section{The IP Module}

The \nedtype{IP} module implements the IPv4 protocol. An IP datagram
is represented by the \cppclass{IPDatagram} message class.

\subsection{Sending a packet over IP}

To send a packet over IP from a higher layer protocol, the module should
fill in an \cppclass{IPControlInfo} object, attach it to the packet with
\cppclass{cMessage}'s \ttt{setControlInfo()} method, the send it to the IP
module.

When IP sends up a packet to a higher layer protocol, it will also attach
an \cppclass{IPControlInfo} to the packet, with the source and destination
IP address, etc. of the IP datagram in which the packet arrived.

IP can serve several higher-layer protocols. When delivering packets to
them, the output gate is determined from the Protocol field in the IP
header. The protocol-to-gateindex mapping must be given in the
\ttt{protocolMapping} string parameter, in the following format:

\begin{verbatim}
protocolnumber:gateindex, protocolnumber:gateindex, ...
\end{verbatim}

The recommended setting is:

\begin{itemize}
  \item TCP (6) : 0
  \item UDP (17) : 1
  \item ICMP (1) : 2
  \item IGMP (2) : 3
  \item RSVP (46) : 4
\end{itemize}

That is, \ttt{protocolMapping} should be set to \ttt{"6:0,17:1,1:2,2:3,46:4"}.

\subsection{Routing, and interfacing with lower layers}

The routing table is stored in the module \nedtype{RoutingTable}. When a
datagram needs to be routed, IP queries \nedtype{RoutingTable} for the
output interface (or "port") and next hop address of the packet. This is
done by directly calling C++ methods (such as
\ttt{findBestMatchingRoute(destAddress)}) of \nedtype{RoutingTable}. No
message exchange with \nedtype{RoutingTable} takes place.

A routed datagram will be sent to the \ttt{queueOut} gate with an
\cppclass{IPRoutingDecision} control info object attached to it, which
contains the next hop address and the output interface number.
\ttt{queueOut} is expected to be connected to \nedtype{ARP}.

Routing protocol implementations can query and manipulate the route table
by calling \nedtype{RoutingTable}'s C++ methods.

\subsection{Performance model, QoS}

In the current form, IP contains a FIFO which queues up IP datagrams;
datagrams are processed in order. The processing time is determined by the
\ttt{procDelay} module parameter.

The current performance model comes from the \cppclass{QueueBase} C++ base
class. If you need a more sophisticated performance model, you may change
the module implementation (the IP class), and: (1) override the
startService() method which determines processing time for a packet, or (2)
use a different base class.


\section{The IP routing files}

Routing files are files with \ttt{.irt} or \ttt{.mrt} extension,
and their names are passed in the routingFileName parameter
to RoutingTable modules. RoutingTables are present in all
IP nodes (hosts and routers).

Routing files may contain network interface configuration and static
routes. Both are optional. Network interface entries in the file
configure existing interfaces; static routes are added to the route table.

Interfaces themselves are represented in the simulation by modules
(such as the PPP module). Modules automatically register themselves
with appropriate defaults in the RoutingTable, and entries in the
routing file refine (overwrite) these settings.
Interfaces are identified by names (e.g. ppp0, ppp1, eth0) which
are normally derived from the module's name: a module called
\ttt{"ppp[2]"} in the NED file registers itself as interface ppp2.

An example routing file (copied here from one of the example simulations):

\begin{verbatim}
ifconfig:

# ethernet card 0 to router
name: eth0   inet_addr: 172.0.0.3   MTU: 1500   Metric: 1  BROADCAST MULTICAST
Groups: 225.0.0.1:225.0.1.2:225.0.2.1

# Point to Point link 1 to Host 1
name: ppp0   inet_addr: 172.0.0.4   MTU: 576   Metric: 1

ifconfigend.

route:
172.0.0.2   *           255.255.255.255  H  0   ppp0
172.0.0.4   *           255.255.255.255  H  0   ppp0
default:    10.0.0.13   0.0.0.0          G  0   eth0

225.0.0.1   *           255.255.255.255  H  0   ppp0
225.0.1.2   *           255.255.255.255  H  0   ppp0
225.0.2.1   *           255.255.255.255  H  0   ppp0

225.0.0.0   10.0.0.13   255.0.0.0        G  0   eth0

routeend.
\end{verbatim}

The \ttt{ifconfig...ifconfigend.} part configures interfaces,
and \ttt{route..routeend.} part contains static routes.
The format of these sections roughly corresponds to the output
of the \ttt{ifconfig} and \ttt{netstat -rn} Unix commands.

An interface entry begins with a \ttt{name:} field, and lasts until
the next \ttt{name:} (or until \ttt{ifconfigend.}). It may
be broken into several lines.

Accepted interface fields are:

\begin{itemize}
  \item \ttt{name:} - arbitrary interface name (e.g. eth0, ppp0)
  \item \ttt{inet\_addr:} - IP address
  \item \ttt{Mask:} - netmask
  \item \ttt{Groups:} Multicast groups. 224.0.0.1 is added automatically,
     and 224.0.0.2 also if the node is a router (IPForward==true).
  \item \ttt{MTU:} - MTU on the link (e.g. Ethernet: 1500)
  \item \ttt{Metric:} - integer route metric
  \item flags: \ttt{BROADCAST}, \ttt{MULTICAST}, \ttt{POINTTOPOINT}
\end{itemize}

The following fields are parsed but ignored: \ttt{Bcast},\ttt{encap},
\ttt{HWaddr}.

Interface modules set a good default for MTU, Metric (as 2e9/bitrate) and
flags, but leave inet\_addr and Mask empty. inet\_addr and mask should
be set either from the routing file or by a dynamic network configuration
module.

The route fields are:

\begin{verbatim}
Destination  Gateway  Netmask  Flags  Metric Interface
\end{verbatim}

\textit{Destination}, \textit{Gateway} and \textit{Netmask} have the usual meaning.
The \textit{Destination} field should either be an IP address or "default:"
(to designate the default route). For \textit{Gateway}, \ttt{*} is also
accepted with the meaning \ttt{0.0.0.0}.

\textit{Flags} denotes route type:

\begin{itemize}
  \item \textit{H} "host": direct route (directly attached to the router), and
  \item \textit{G} "gateway": remote route (reached through another router)
\end{itemize}

\textit{Interface} is the interface name, e.g. \ttt{eth0}.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:

