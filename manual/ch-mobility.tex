\chapter{Node Mobility}
\label{cha:mobility}


\section{Overview}

In order to accurately evaluate a protocol for an ad-hoc network,
it is important to use a realistic model for the motion of mobile
hosts. Signal strengths, radio interference and channel occupancy
depends on the distances between nodes. The choice of the mobility
model can significantly influence the results of a simulation
(e.g. data packet delivery ratio, end-to-end delay, average hop count)
as shown in \cite{Camp02asurvey}.

There are two methods for incorporating mobility into simulations:
using traces and synthetic models. Traces contains recorded motion
of the mobile hosts, as observed in real life system. Synthetic models
use mathematical models for describing the behaviour of the mobile hosts.

There are mobility models that represent mobile nodes whose movements 
are independent of each other (entity models) and mobility models
that represent mobile nodes whose movements are dependent on each other
(group models). Some of most frequently use entity models are the
Random Walk Mobility Model, Random Waypoint Mobility Model, Random
Direction Mobility Model, Gauss-Markov Mobility Model, City Section
Mobility Model. The group models include the Column Mobility Model,
Nomadic Community Mobility Model, Pursue Mobility Model,
Reference Point Group Mobility Model.

The INET framework has components for the following trace files:

\begin{description}
\item[Bonn Motion] native file format of the BonnMotion scenario generation
                   tool (http://net.cs.uni-bonn.de/wg/cs/applications/bonnmotion/).
\item[Ns2] trace file generated by the CMU's scenario generator that used in Ns2.
\item[ANSim] XML trace file of the ANSim (Ad-Hoc Network Simulation) tool.
\end{description}

It is easy to integrate new entity mobility models into the INET framework,
but group mobility is not supported yet. Therefore all the models
shipped with INET are implementations of entitiy models:

\begin{description}
\item[Deterministic Motion] Support fixed position nodes and nodes
      moving on a linear, circular, rectangular paths.
\item[Random Waypoint] model includes pause times between changes
      in destination and speed.
\item[Gauss-Markov] model uses one tuning parameter to vary the degree
      of randomness in mobility pattern.
\item[Mass Mobility] models a massive mobile host with momentum.
\item[Chiang Mobility] uses a probabilistic transition matrix to change
      the state of motion of the node.
\end{description}

\section{Mobility in INET}

In INET mobile nodes have to contain a module implementing the
\nedtype{IMobility} marker interface. This module stores the current
coordinates of the node and is responsible for updating the position
periodically and publishing the changed coordinates through the
notification board of the node.

The p[0] and p[1] fields of the display string of the node is
also updated, so if the simulation run is animated, the node is
actually moving on the screen. The current position of the node
can be obtained from the display string.

The radio simulations has a Channel Control module that takes case of
establishing communication channels between nodes that are within
communication distance and tearing down the connections when they
move out of range. The radio components of the nodes subscribe to
the notifications of node movements and using the signalling mechanism
introduced in OMNeT++ 4.1 to notify the Channel Controller about their
position.

There are two possibilities to implement a new mobility model. The simpler but
limited one is to use \nedtype{TurtleMobility} as the mobility component and to
write a script similar to the turtle graphics of LOGO. The second is to
implement a simple module in C++. In this case the C++ class of the mobility
module should be derived from \cppclass{MobilityBase} and its NED type should
implement the \nedtype{IMobility} interface.

The \nedtype{IMobility} defined in the \nedtype{inet.base.mobility} package.
This package contains an implementation of the interface
(\nedtype{MobilityBase}) that defines the parameters of the
\cppclass{BasicMobility} simple module.

% TODO remove NoMobility module, because it is not used.

\subsection{BasicMobility class}

The abstract \cppclass{BasicMobility} class is the base of the mobility
modules defined in the INET framework. This class allows to define
a rectangular area that the node can not leave. The rectangle is configured
by setting the \fpar{constraintAreaX}, \fpar{constraintAreaY},
\fpar{constraintAreaWidth} and \fpar{constraintAreaHeight} parameters.

When the module is initialized it sets the initial position of the node
by calling the \ffunc{initPos()} method.
The default implementation of this method sets the position from the
display string if the \fpar{initFromDisplayString} parameter is true.
Otherwise the position can be given as the \fpar{initialX} and
\fpar{initialY} parameters. If neither of these parameters are given,
a random initial position is choosen within the contraint area.

The module is responsible for periodically updating the position.
For this purpose it should send timer messages to itself. These messages
are processed in the \ffunc{handleSelfMessage()} method. In derived
classes, \ffunc{handleSelfMessage} should compute the new position
and update the display string and publish the new position by calling
\ffunc{positionUpdated()} method.

When the node reaches the boundary of the constraint area, the mobility
component has to prevent the node to exit. It can call the
\ffunc{handleIfOutside} method, that offers the following policies:

\begin{itemize}
  \item reflect of the wall
  \item reappear at the opposite edge (torus area)
  \item placed at a randomly chosen position of the area
  \item stop the simulation with an error
\end{itemize}

% TODO cut position into constraintArea by min/max (as policy or always?)
% current implementation does not guarantee that position is within
% the constraintArea after handleIfOutside() called.

\subsection{LineSegmentsMobilityBase}

The path of a mobile node often consist of linear movements of constant
speed. The node moves with some speed for some time, then with another
speed for another duration and so on. If a mobility model fits this
description, it might be suitable to derive the implementing C++ class
from \cppclass{LineSegmentsMobilityBase}.

The module first choose a target position and a target time by calling
the \ffunc{setTargetPosition} method. If the target position differs
from the current position, it starts to move toward the target and
updates the position in the configured \fpar{updateInterval} intervals.
When the target position reached, it chooses a new target. The node
should be confined within the constraint area, for this the module calls
\ffunc{fixHostPositionIfOutside}. Subclasses should redefine
\ffunc{fixHostPositionIfOutside} and can call \ffunc{handleIfOutside} to
adjust the coordinates.

host moves the first time after some random delay to avoid synchronized movements
node can be stopped by setting stationary=true

% FIXME: target time is only approximated if (targetTime-simtime)/updateInterval not an integer
% because `move` messages are always scheduled in `updateInterval` steps. This could be fixed
% by scheduling the last self message exactly at targetTime.
% Consider an updateInterval computed from an updateDistance and speed, because position change
% may be irrevelant during a preconfigured updateInterval.

\section{Implemented models}

\subsection{Deterministic movements}

\begin{description}

\item[NullMobility] This mobility module does nothing;
it can be used for stationary nodes.

\item[StaticGridMobility] Places all nodes in a rectangular grid.

% TODO it always creates an N x N grid, generalize

\item[LinearMobility] This is a linear mobility model with speed,
angle and acceleration parameters. Angle only changes when the mobile
node hits a wall: then it reflects off the wall at the same angle.

% TODO if acceleration is positive its speed grows unbounded, so
% it can jump far beyond the constraint area within 'updateInterval'
% time. handleIfOutside(MIRROR) does not handle this case properly.

\item[CircleMobility] Moves the node around a circle with constant speed.
The node bounces from the bounds of the constraint area.
The circle is given by the \fpar{cx}, \fpar{cy} and \fpar{r} parameters,
The initial position determined by the \fpar{startAngle} parameter.
The position of the node is refreshed in \fpar{updateInterval} steps.

% TODO same problem with handleIfOutside(MIRROR) if the radius is too big.

\item[RectangleMobility] Moves the node around the constraint area.
configuration: speed, startPos, updateInterval
% should be derived from LineSegmentsMobilityBase?

\end{description}

\subsection{Random movements}

\begin{description}

\item[RandomWPMobility]

In the Random Waypoint mobility model the nodes move in line segments. For each
line segment, a random destination position (distributed uniformly over the
playground) and a random speed is chosen. You can define a speed as a variate
from which a new value will be drawn for each line segment; it is customary to
specify it as \ttt{uniform(minSpeed, maxSpeed)}. When the node reaches the
target position, it waits for the time \fpar{waitTime} which can also be defined as a
variate. After this time the the algorithm calculates a new random position, etc.

\item[GaussMarkovMobility] The Gauss-Markov model contains a tuning
parameter, that control the randomness in the movement of the node.
Let the magnitude and direction of speed of the node at the $n$th time step be
$s_n$ and $d_n$. The next speed and direction is computed as

$$ s_{n+1} = \alpha s_n + (1 - \alpha) \bar{s} +
             \sqrt{(1-\alpha^2)} s_{x_n} $$

$$ d_{n+1} = \alpha s_n + (1 - \alpha) \bar{d} +
             \sqrt{(1-\alpha^2)} s_{x_n} $$

where $\bar{s}$ and $\bar{d}$ are constants representing the mean value
of speed and direction as $n \to \infty$; and $s_{x_n}$ and $d_{x_n}$
are random variables with Gaussian distribution.

Totally random walk (Brownian motion) is obtained by setting $\alpha=0$,
while $\alpha=1$ results a linear motion.

To ensure that the node does not remain at the boundary of the constraint
area for a long time, the mean value of the direction ($\bar{d}$) modified
as the node enters the margin area. For example at the right edge of the
area it is set to 180 degrees, so the new direction is away from the edge.

% FIXME the GaussMarkovMobility module has only one variance parameter.
%       it should have separate speed and direction parameters

\item[MassMobility] 

This is a random mobility model for a mobile host with
a mass. It is the one used in \cite{Perkins99optimizedsmooth}.

\begin{quote}
"An MH moves within the room according to the following pattern. It moves
along a straight line for a certain period of time before it makes a turn.
This moving period is a random number, normally distributed with average of
5 seconds and standard deviation of 0.1 second. When it makes a turn, the
new direction (angle) in which it will move is a normally distributed
random number with average equal to the previous direction and standard
deviation of 30 degrees. Its speed is also a normally distributed random
number, with a controlled average, ranging from 0.1 to 0.45 (unit/sec), and
standard deviation of 0.01 (unit/sec). A new such random number is picked
as its speed when it makes a turn. This pattern of mobility is intended to
model node movement during which the nodes have momentum, and thus do not
start, stop, or turn abruptly. When it hits a wall, it reflects off the
wall at the same angle; in our simulated world, there is little other
choice."
\end{quote}

This implementation can be parameterized a bit more, via the
\fpar{changeInterval}, \fpar{changeAngleBy} and \fpar{changeSpeedBy} parameters.
The parameters described above correspond to the following settings:

\begin{inifile}
changeInterval = normal(5, 0.1)
changeAngleBy = normal(0, 30)
speed = normal(avgSpeed, 0.01)
\end{inifile}

\item[ChiangMobility] Chiang's random walk movement model
(\cite{Chiang98wirelessnetwork}).

In this model, the state of the mobile node in each direction (x and y) can be:

\begin{itemize}
  \item 0: the node stays in its current position
  \item 1: the node moves in the previous direction
  \item 2: the node moves in the next direction
\end{itemize}

The $(i,j)$ element of the state transition matrix determines the
probability that the state changes from $i$ to $j$:

$$ \left(
\begin{array}{ccc}
  0 & 0.5 & 0.5 \\
  0.3 & 0.7 & 0 \\
  0.3 & 0 & 0.7
\end{array}
\right) $$

The \nedtype{ChiangMobility} module supports the following parameters:
\begin{itemize}
  \item \fpar{updateInterval} position update interval
  \item \fpar{stateTransitionInterval} state update interval
  \item \fpar{speed}: the speed of the node
\end{itemize}


% FIXME implementation is not correct

\item[ConstSpeedMobility]

\nedtype{ConstSpeedMobility} does not use one of the standard mobility
approaches. The user can define a velocity for each Host and an update interval. If
the velocity is greater than zero (i.e. the Host is not stationary) the
\nedtype{ConstSpeedMobility} module calculates a random target position for the
Host. Depending to the update interval and the velocity it calculates the number of
steps to reach the destination and the step-size. Every update interval
\nedtype{ConstSpeedMobility} calculates the new position on its way to the
target position and updates the display. Once the target position is reached
\nedtype{ConstSpeedMobility} calculates a new target position.

This component has been taken over from Mobility Framework 1.0a5.

% TODO could be simpler if were derived from LineSegmentsMobilityBase
% TODO 'vHost' parameter should be called 'speed' for consistency
% FIXME the implementation is buggy, it only approximately constant speed (due
% to rounding)
% FIXME this is a special case of RandomWPMobility, remove


\end{description}

\subsection{Replaying trace files}

\begin{description}

\item[BonnMotionMobility] Uses the native file format of BonnMotion
(http://www.cs.uni-bonn.de/IV/BonnMotion/).

The file is a plain text file, where every line describes the motion
of one host. A line consists of one or more (t, x, y) triplets of real
numbers, like:

\begin{verbatim}
t1 x1 y1 t2 x2 y2 t3 x3 y3 t4 x4 y4 ...
\end{verbatim}

The meaning is that the given node gets to $(xk,yk)$ at $tk$. There's no
separate notation for wait, so x and y coordinates will be repeated there.

\item[Ns2Mobility] Nodes are moving according to the trace files used
in NS2.
The trace file has this format:

\begin{verbatim}
# '#' starts a comment, ends at the end of line
$node_(<id>) set X_ <x> # sets x coordinate of the node identified by <id>
$node_(<id>) set Y_ <y> # sets y coordinate of the node identified by <id>
$node_(<id>) set Z_ <z> # sets z coordinate (ignored)
$ns at $time "$node_(<id>) setdest <x> <y> <speed>" # at $time start moving
towards <x>,<y> with <speed>
\end{verbatim}

The \nedtype{Ns2MotionMobility} module has the following parameters:

\begin{itemize}
  \item \fpar{traceFile} the Ns2 trace file
  \item \fpar{nodeId} node identifier in the trace file; -1 gets substituted by
  parent module's index
  \item \fpar{updateInterval} time interval to update host position
  \item \fpar{scrollX},\fpar{scrollY} user specified translation of the
  coordinates
\end{itemize}

% TODO cleaning the code
%      cached file access as in BonnMotionMobility

\item[ANSimMobility]
Nodes are moving along paths defined in an ANSim trace file.
The trace file contains the segments of the node trajectories
in \verb!<position_change>! elements of the XML file.

\begin{verbatim}
<!ELEMENT mobility (position_change*)>
<!ELEMENT position_change (node_id, start_time, end_time, destination)>
<!ELEMENT node_id (#PCDATA)>
<!ELEMENT start_time (#PCDATA)>
<!ELEMENT end_time (#PCDATA)>
<!ELEMENT destination (xpos, ypos)>
<!ELEMENT xpos (#PCDATA)>
<!ELEMENT ypos (#PCDATA)>
\end{verbatim}

% FIXME there should be pauses if end_time < next start_time!
%       currently the node immediately starts the next move

Parameters:

\begin{itemize}
  \item \fpar{ansimTrace} the trace file
  \item \fpar{nodeId} the \verb!node_id! of this node, -1 gets substituted to
  parent module's index
  \item \fpar{updateInterval} time interval to update the hosts position
\end{itemize}
 
\end{description}




\section{Scripting}

A LOGO-style movement model, with the script coming
from XML. It can be useful for describing random as well as deterministic
scenarios.

Commands (XML element names) are: repeat, set, forward, turn, wait,
moveto, and moveby.

Accepted attributes:

\begin{itemize}
  \item repeat: n (optional)
  \item set: x, y, speed, angle, borderPolicy (all optional)
  \item forward: d, t (at last one of them must be present)
  \item turn: angle (required)
  \item wait: t (required)
  \item moveto: x, y, t (all optional)
  \item moveby: x, y, t (all optional)
\end{itemize}

Attribute values can be literal numbers (e.g. x="100"), or any
distribution accepted in omnetpp.ini (e.g. speed="uniform(10,20)").
A new value will be chosen each time the statement is executed.
The \verb!$MINX!, \verb!$MAXX!, \verb!$MINY! and \verb!$MAXY! strings
will be substituted with the limits of constraint area, respectively.

t is time interval, calculated from the end of the previous movement.
x, y are absolute coordinates with <set> and <moveto>, and relative
with <moveby>. angle is clockwise in degrees, with 0 pointing west.
d is distance in meters (speed is m/s).

borderPolicy controls what happens when a node reaches the edge of the
playground, and can take one of the values "reflect", "wrap",
"placerandomly". In the first case, the node reflects off the wall;
with "wrap", it'll come in on the other side (torus); and with
"placerandomly", it will be placed at a random position on the
playground.

In addition to the node position, the module maintains two interval variables,
'speed' and 'angle', which can be adjusted by <set> and <turn>.
The <forward> statement, if only t or d is given, uses the speed variable.
If you specify d and t together, that determines speed as well,
so the speed variable will be ignored completely.

Likewise, <moveto> and <moveby> will ignore the angle variable,
and will only use the speed variable if the t attribute is omitted.

If the repeat count n is omitted for the <repeat> statement, that
means an infinite loop.



You can find the DTD with the sources: TurtleMobility.dtd.

\begin{verbatim}
<!ELEMENT movements (movement)*>

<!ELEMENT movement (repeat|set|forward|turn|wait|moveto|moveby)*>
<!ATTLIST movement id NMTOKEN #IMPLIED>

<!ELEMENT repeat (repeat|set|forward|turn|wait|moveto|moveby)*>
<!ATTLIST repeat n CDATA #IMPLIED>

<!ELEMENT set EMPTY>
<!ATTLIST set x     CDATA #IMPLIED
              y     CDATA #IMPLIED
              speed CDATA #IMPLIED
              angle CDATA #IMPLIED
              borderPolicy (reflect|wrap|placerandomly|error) #IMPLIED>

<!ELEMENT forward EMPTY>
<!ATTLIST forward d CDATA #IMPLIED
                  t CDATA #IMPLIED>

<!ELEMENT turn EMPTY>
<!ATTLIST turn angle CDATA #REQUIRED>

<!ELEMENT wait EMPTY>
<!ATTLIST wait t CDATA #REQUIRED>

<!ELEMENT moveto EMPTY>
<!ATTLIST moveto x CDATA #IMPLIED
                 y CDATA #IMPLIED
                 t CDATA #IMPLIED>

<!ELEMENT moveby EMPTY>
<!ATTLIST moveby x CDATA #IMPLIED
                 y CDATA #IMPLIED
                 t CDATA #IMPLIED>
\end{verbatim}

% TODO examples

Examples

Node will move along a square's borders:

\begin{verbatim}
    <movement>
        <set speed="10" angle="180"/>
        <repeat n="4">
            <forward d="50"/>
            <turn angle="90"/>
        </repeat>
    </movement>
\end{verbatim}

MassMobility:

\begin{verbatim}
    <movement>
        <repeat>
            <set speed="uniform(10,20)"/>
            <turn angle="uniform(-30,30)"/>
            <forward t="uniform(0.1,1)"/>
        </repeat>
    </movement>
\end{verbatim}

Random Waypoint:

\begin{verbatim}
    <movement>
        <repeat>
            <set speed="uniform(20,60)"/>
            <moveto x="uniform($MINX,$MAXX)" y="uniform($MINY,$MAXY)"/>
        </repeat>
    </movement>
\end{verbatim}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:


