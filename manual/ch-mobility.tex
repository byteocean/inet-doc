\chapter{Node Mobility}
\label{cha:mobility}


\section{Overview}

general overview, user level

\section{Mobility in OMNeT++}

In OMNeT++ mobile nodes have to contain a module implementing the
\nedtype{IMobility} marker interface. This module stores the current
coordinates of the node and is responsible for updating the position
periodically and publishing the changed coordinates through the
notification board of the node.

radio modules: subscribe notification board, sending signals to
ChannelController with their position

The \nedtype{IMobility} defined in the \nedtype{inet.base.mobility} package.
This package contains an implementation of the interface
(\nedtype{MobilityBase}) that defines the parameters of the
\cppclass{BasicMobility} simple module. Most mobility modules extend this
abstract class.

% TODO remove NoMobility module, because it is not used.

\subsection{BasicMobility class}

The abstract \cppclass{BasicMobility} class is the base of the mobility
modules defined in the INET framework. This class allows to define
a rectangular area that the node can not leave. The rectangle is configured
by setting the \fpar{constraintAreaX}, \fpar{constraintAreaY},
\fpar{constraintAreaWidth} and \fpar{constraintAreaHeight} parameters.

When the module is initialized it sets the initial position of the node
by calling the \ffunc{initPos()} method.
The default implementation of this method sets the position from the
display string if the \fpar{initFromDisplayString} parameter is true.
Otherwise the position can be given as the \fpar{initialX} and
\fpar{initialY} parameters. If neither of these parameters are given,
a random initial position is choosen.

The module is responsible for periodically updating the position.
For this purpose it should send timer messages to itself. These messages
are processed in the \ffunc{handleSelfMessage()} method. In derived
classes, \ffunc{handleSelfMessage} should compute the new position
and update the display string and publish the new position by calling
\ffunc{positionUpdated()} method.



BorderPolicy: reflect/wrap/placerandomly/raiseerror

% TODO cut position into constraintArea by min/max (as policy or always?)
% current implementation does not guarantee that position is within
% the constraintArea after handleIfOutside() called.

\subsection{LineSegmentsMobilityBase}

The path of a mobile node often consist of linear movements of constant
speed. The node moves with some speed for some time, then with another
speed for another duration and so on. If a mobility model fits this
description, it might be suitable to derive the implementing C++ class
from \cppclass{LineSegmentsMobilityBase}.

The module first choose a target position and a target time by calling
the \ffunc{setTargetPosition} method. If the target position differs
from the current position, it starts to move toward the target and
updates the position in the configured \fpar{updateInterval} intervals.
When the target position reached, it chooses a new target. The node
should be confined within the constraint area, for this the module calls
\ffunc{fixHostPositionIfOutside}. Subclasses should redefine
\ffunc{fixHostPositionIfOutside} and can call handleIfOutside() to
adjust the coordinates.

host moves the first time after some random delay to avoid synchronized movements
node can be stopped by setting stationary=true

% FIXME: target time is only approximated if (targetTime-simtime)/updateInterval not an integer
% because `move` messages are always scheduled in `updateInterval` steps. This could be fixed
% by scheduling the last self message exactly at targetTime.
% Consider an updateInterval computed from an updateDistance and speed, because position change
% may be irrevelant during a preconfigured updateInterval.

\section{Implemented mobility models}

\subsection{Predefined paths}

\begin{description}

\item[NullMobility] This mobility module does nothing;
it can be used for stationary nodes.

\item[StaticGridMobility] Places all nodes in a rectangular grid.

% TODO it always creates an N x N grid, generalize

\item[LinearMobility] This is a linear mobility model with speed,
angle and acceleration parameters. Angle only changes when the mobile
node hits a wall: then it reflects off the wall at the same angle.

% TODO if acceleration is positive its speed grows unbounded, so
% it can jump far beyond the constraint area within 'updateInterval'
% time. handleIfOutside(MIRROR) does not handle this case properly.

\item[CircleMobility] Moves the node around a circle with constant speed.
The node bounces from the bounds of the constraint area.
The circle is given by the \fpar{cx}, \fpar{cy} and \fpar{r} parameters,
The initial position determined by the \fpar{startAngle} parameter.
The position of the node is refreshed in \fpar{updateInterval} steps.

% TODO same problem with handleIfOutside(MIRROR) if the radius is too big.

\item[RectangleMobility] Moves the node around the constraint area.
configuration: speed, startPos, updateInterval
% should be derived from LineSegmentsMobilityBase?

\end{description}

\subsection{Random movements}

\begin{description}
\item[ConstSpeedMobility]

\nedtype{ConstSpeedMobility} does not use one of the standard mobility
approaches. The user can define a velocity for each Host and an update interval. If
the velocity is greater than zero (i.e. the Host is not stationary) the
\nedtype{ConstSpeedMobility} module calculates a random target position for the
Host. Depending to the update interval and the velocity it calculates the number of
steps to reach the destination and the step-size. Every update interval
\nedtype{ConstSpeedMobility} calculates the new position on its way to the
target position and updates the display. Once the target position is reached
\nedtype{ConstSpeedMobility} calculates a new target position.

This component has been taken over from Mobility Framework 1.0a5.

% TODO could be simpler if were derived from LineSegmentsMobilityBase
% TODO 'vHost' parameter should be called 'speed' for consistency
% FIXME the implementation is buggy, it only approximately constant speed (due
% to rounding)

\item[RandomWPMobility]

In the Random Waypoint mobility model the nodes move in line segments. For each
line segment, a random destination position (distributed uniformly over the
playground) and a random speed is chosen. You can define a speed as a variate
from which a new value will be drawn for each line segment; it is customary to
specify it as \ttt{uniform(minSpeed, maxSpeed)}. When the node reaches the
target position, it waits for the time \fpar{waitTime} which can also be defined as a
variate. After this time the the algorithm calculates a new random position, etc.

\item[MassMobility] 

This is a random mobility model for a mobile host with
a mass. It is the one used in "Optimized Smooth Handoffs in Mobile IP" by
Perkins\&Wang.

\begin{quote}
"An MH moves within the room according to the following pattern. It moves
along a straight line for a certain period of time before it makes a turn.
This moving period is a random number, normally distributed with average of
5 seconds and standard deviation of 0.1 second. When it makes a turn, the
new direction (angle) in which it will move is a normally distributed
random number with average equal to the previous direction and standard
deviation of 30 degrees. Its speed is also a normally distributed random
number, with a controlled average, ranging from 0.1 to 0.45 (unit/sec), and
standard deviation of 0.01 (unit/sec). A new such random number is picked
as its speed when it makes a turn. This pattern of mobility is intended to
model node movement during which the nodes have momentum, and thus do not
start, stop, or turn abruptly. When it hits a wall, it reflects off the
wall at the same angle; in our simulated world, there is little other
choice."
\end{quote}

This implementation can be parameterized a bit more, via the
\fpar{changeInterval}, \fpar{changeAngleBy} and \fpar{changeSpeedBy} parameters.
The parameters described above correspond to the following settings:

\begin{inifile}
changeInterval = normal(5, 0.1)
changeAngleBy = normal(0, 30)
speed = normal(avgSpeed, 0.01)
\end{inifile}

\item[GaussMarkovMobility] TODO
\item[ChiangMobility] Chiang's random walk movement model.
\end{description}

\subsection{Scripted movements}

\begin{description}
\item[TurtleMobility] A LOGO-style movement model, with the script coming
from XML. It can be useful for describing random as well as deterministic
scenarios.

Commands (XML element names) are: repeat, set, forward, turn, wait,
moveto, and moveby.

Accepted attributes:
   - repeat: n (optional)
   - set: x, y, speed, angle, borderPolicy (all optional)
   - forward: d, t (at last one of them must be present)
   - turn: angle (required)
   - wait: t (required)
   - moveto: x, y, t (all optional)
   - moveby: x, y, t (all optional)

Attribute values can be literal numbers (e.g. x="100"), or any
distribution accepted in omnetpp.ini (e.g. speed="uniform(10,20)").
A new value will be chosen each time the statement is executed.
The $MINX, $MAXX, $MINY and $MAXY strings will be substituted with the
limits of constraint area, respectively.

t is time interval, calculated from the end of the previous movement.
x, y are absolute coordinates with <set> and <moveto>, and relative
with <moveby>. angle is clockwise in degrees, with 0 pointing west.
d is distance in meters (speed is m/s).

borderPolicy controls what happens when a node reaches the edge of the
playground, and can take one of the values "reflect", "wrap",
"placerandomly". In the first case, the node reflects off the wall;
with "wrap", it'll come in on the other side (torus); and with
"placerandomly", it will be placed at a random position on the
playground.

In addition to the node position, the module maintains two interval variables,
'speed' and 'angle', which can be adjusted by <set> and <turn>.
The <forward> statement, if only t or d is given, uses the speed variable.
If you specify d and t together, that determines speed as well,
so the speed variable will be ignored completely.

Likewise, <moveto> and <moveby> will ignore the angle variable,
and will only use the speed variable if the t attribute is omitted.

If the repeat count n is omitted for the <repeat> statement, that
means an infinite loop.



You can find the DTD with the sources: TurtleMobility.dtd.

% TODO examples

\item[ANSimMobility]
Nodes are moving along paths defined in an ANSim trace file.
The trace file contains the segments of the node trajectories
in \verb!<position_change>! elements of the XML file.

\item[BonnMotionMobility] Uses the native file format of BonnMotion
(http://www.cs.uni-bonn.de/IV/BonnMotion/).

The file is a plain text file, where every line describes the motion
of one host. A line consists of one or more (t, x, y) triplets of real
numbers, like:

t1 x1 y1 t2 x2 y2 t3 x3 y3 t4 x4 y4 ...

The meaning is that the given node gets to (xk,yk) at tk. There's no
separate notation for wait, so x and y coordinates will be repeated there.

\item[Ns2Mobility] TODO
\end{description}

\section{Developing new mobility models}
 (ned, c++)


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:


